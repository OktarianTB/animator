#include "AdaptiveBezierCurveEvaluator.h"
#include <assert.h>
#include <algorithm>

using namespace std;

void AdaptiveBezierCurveEvaluator::evaluateCurve(const std::vector<Point>& ptvCtrlPts,
	std::vector<Point>& ptvEvaluatedCurvePts,
	const float& fAniLength,
	const bool& bWrap) const
{
	int iCtrlPtCount = ptvCtrlPts.size();
	int numSegments = 20; // this decides how smooth the line looks
	float step = 1 / (float)numSegments;

	std::vector<Point> evaluatedPts; // these are the evaluating points which are returned
	std::vector<Point> blacklist; // these are points that shouldn't be added as evaluating points

	if (bWrap)
	{
		if (iCtrlPtCount % 3 == 0) // we can wrap using bezier curve
		{
			Point p0(ptvCtrlPts[iCtrlPtCount - 1].x - fAniLength, ptvCtrlPts[iCtrlPtCount - 1].y);
			Point p1(ptvCtrlPts[iCtrlPtCount - 2].x - fAniLength, ptvCtrlPts[iCtrlPtCount - 2].y);
			Point p2(ptvCtrlPts[iCtrlPtCount - 3].x - fAniLength, ptvCtrlPts[iCtrlPtCount - 3].y);
			Point p3(ptvCtrlPts[0].x + fAniLength, ptvCtrlPts[0].y);

			displayBezier(p0, p1, p2, ptvCtrlPts[0], evaluatedPts);
			displayBezier(ptvCtrlPts[iCtrlPtCount - 3], ptvCtrlPts[iCtrlPtCount - 2], ptvCtrlPts[iCtrlPtCount - 1], p3, evaluatedPts);

			blacklist.push_back(ptvCtrlPts[iCtrlPtCount - 2]);
			blacklist.push_back(ptvCtrlPts[iCtrlPtCount - 1]);
		}
		else //todo
		{
			// default to linear interpolation
			Point p0(ptvCtrlPts[iCtrlPtCount - 1].x - fAniLength, ptvCtrlPts[iCtrlPtCount - 1].y);
			evaluatedPts.push_back(p0);

			Point p1(ptvCtrlPts[0].x + fAniLength, ptvCtrlPts[0].y);
			evaluatedPts.push_back(p1);
		}
	}
	else {
		evaluatedPts.push_back(Point(0.0, ptvCtrlPts[0].y));
		evaluatedPts.push_back(Point(fAniLength, ptvCtrlPts[iCtrlPtCount - 1].y));
	}

	int i = 0;
	while (i < iCtrlPtCount)
	{
		// Add first and last control points
		if ((i == 0 || i == iCtrlPtCount - 1) && std::find(blacklist.begin(), blacklist.end(), ptvCtrlPts[i]) == blacklist.end())
		{
			evaluatedPts.push_back(ptvCtrlPts[i]);
		}

		// If sufficient control points, create bezier curve
		if (i + 3 < iCtrlPtCount)
		{
			Point p0(ptvCtrlPts[i].x, ptvCtrlPts[i].y);
			Point p1(ptvCtrlPts[i+1].x, ptvCtrlPts[i+1].y);
			Point p2(ptvCtrlPts[i+2].x, ptvCtrlPts[i+2].y);
			Point p3(ptvCtrlPts[i+3].x, ptvCtrlPts[i+3].y);

			displayBezier(p0, p1, p2, p3, evaluatedPts);

			i += 3;
			continue;
		}
		// Otherwise add intermediary control points
		else if (i > 0 && i < iCtrlPtCount - 1 && std::find(blacklist.begin(), blacklist.end(), ptvCtrlPts[i]) == blacklist.end()) {
			evaluatedPts.push_back(ptvCtrlPts[i]);
		}

		i++;
	}

	ptvEvaluatedCurvePts = evaluatedPts;
	cout << "Number of points generated by adaptive Bezier: " << evaluatedPts.size() << ", with flatness factor: " << ModelerUI::getFlatness() << endl;
}

void AdaptiveBezierCurveEvaluator::displayBezier(Point p0, Point p1, Point p2, Point p3, std::vector<Point>& evaluatedPts) const
{
	if (isFlatEnough(p0, p1, p2, p3))
	{
		evaluatedPts.push_back(p0);
		evaluatedPts.push_back(p3);
	}
	else
	{
		Point q0((p0.x + p1.x) / 2.0, (p0.y + p1.y) / 2.0);
		Point q1((p1.x + p2.x) / 2.0, (p1.y + p2.y) / 2.0);
		Point q2((p2.x + p3.x) / 2.0, (p2.y + p3.y) / 2.0);

		Point r0((q0.x + q1.x) / 2.0, (q0.y + q1.y) / 2.0);
		Point r1((q1.x + q2.x) / 2.0, (q1.y + q2.y) / 2.0);

		Point s0((r0.x + r1.x) / 2.0, (r0.y + r1.y) / 2.0);

		displayBezier(p0, q0, r0, s0, evaluatedPts);
		displayBezier(s0, r1, q2, p3, evaluatedPts);
	}
}

bool AdaptiveBezierCurveEvaluator::isFlatEnough(Point p0, Point p1, Point p2, Point p3) const
{
	float curveFlatness = ModelerUI::getFlatness();

	float top = p0.distance(p1) + p1.distance(p2) + p2.distance(p3);
	float bottom = p0.distance(p3);

	if (top <= curveFlatness * bottom)
		return true;

	return false;
}
